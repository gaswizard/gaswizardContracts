// SPDX-License-Identifier: none

pragma solidity ^0.8.22;
    
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";


interface AggregatorV3Interface {

  function decimals() external view returns (uint);
  function description() external view returns (string memory); 
  function version() external view returns (uint);

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint roundId,
      uint answer,
      uint startedAt,
      uint updatedAt,
      uint answeredInRound
    );
  function latestRoundData() 
    external 
    view 
    returns ( 
      uint roundId, 
      uint answer, 
      uint startedAt, 
      uint updatedAt,  
      uint answeredInRound   
    );

}
contract PriceConsumerV3 {     
 
    AggregatorV3Interface internal priceFeed;
    AggregatorV3Interface internal btcPriceFeed;
    AggregatorV3Interface internal ethPriceFeed;

   
       // mainnet
    constructor() {   
        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE); 
        btcPriceFeed = AggregatorV3Interface(0x264990fbd0A4796A3E3d8E37C4d5F87a3aCa5Ebf); 
        ethPriceFeed = AggregatorV3Interface(0x9ef1B8c0E4F7dc8bF5719Ea496883DC6401d5b2e); 

    }


    function getThePrice() public view returns (uint) {
        (
            uint roundID, 
            uint price,  
            uint startedAt,
            uint timeStamp,
            uint answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }

     function getThePriceBtc() public view returns (uint) {
        (
            uint roundID, 
            uint price,
            uint startedAt,
            uint timeStamp,
            uint answeredInRound
        ) = btcPriceFeed.latestRoundData();
        return price;
    }

     function getThePriceEth() public view returns (uint) {
        (
            uint roundID, 
            uint price,
            uint startedAt,
            uint timeStamp,
            uint answeredInRound
        ) = ethPriceFeed.latestRoundData();
        return price;
    }
}


interface BEP20 {
    function totalSupply() external view returns (uint theTotalSupply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}  

contract GasWizard is ReentrancyGuard {  
  
   PriceConsumerV3 priceConsumerV3 = new PriceConsumerV3(); 
   uint public priceOfBNB = priceConsumerV3.getThePrice();
   uint public priceOfWbtc = priceConsumerV3.getThePriceBtc(); 
   uint public priceOfWeth = priceConsumerV3.getThePriceEth();
                  
                  
  struct Tariff {
    uint time;  
    uint percent;
  }
  
  struct Deposit { 
    uint tariff;
    uint amount;
    uint tokenAmount;
    uint at;
  }
  
  struct Investor {
    bool registered;
    Deposit[] deposits;
    uint invested;
    
  } 

   struct TokenPurchase {
        address buyer; 
        uint amount;
        uint timestamp;
        uint amountType ;  // 0 = bnb , 1 =token 

    }  

    TokenPurchase[] public allTokenPurchases;
 
 uint public MIN_DEPOSIT_BUSD; 
    
 

  // mainnet
   address public wbtc = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;   // btc Mainnet Address
   address public weth = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;  //  eth Mainnet Address
   address public usdt = 0x55d398326f99059fF775485246999027B3197955;  // usdt Mainnet Address
   address public usdc = 0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d;  // Usdc Mainnet Address 
   
  uint public tokenPrice;
  uint public tokenPriceDecimal;



  event OwnershipTransferred(address);
  
  address public owner = msg.sender;
    address public owner1 = 0x5139404F178Bba4Cd92fCf192cccF18db90Dd26d ;

  
  
  uint public totalInvested;
    // address public contractAddr = 0x4a9C72024E22fd901077E41D0fE417395c978fAB;

   address  payable  public   contractAddr = payable(0x4a9C72024E22fd901077E41D0fE417395c978fAB);


  mapping (address => Investor) public investors;
  mapping(address => TokenPurchase[]) public tokenPurchases;
  event DepositAt(address user, uint tariff, uint amount);
  event Withdraw(address user, uint amount);
  
  constructor() {
    tokenPrice = 1;
    tokenPriceDecimal = 3;

  }



function buyTokenWithbnb(address payable _to) external payable { 
    uint tariff = 0;
    require(msg.value >= 0);
    priceOfBNB = priceConsumerV3.getThePrice();
    uint tokenVal = (msg.value * priceOfBNB * 10**tokenPriceDecimal) / (tokenPrice * 100000000);
    
    if (isContract(_to)) {
        (bool success, ) = _to.call{value: msg.value}("");
        require(success, "Transfer to contract failed");
    } else {
        _to.transfer(msg.value);
    }
    
    investors[msg.sender].invested += tokenVal;
    investors[msg.sender].deposits.push(Deposit(tariff, msg.value, tokenVal, block.timestamp));
    allTokenPurchases.push(TokenPurchase(msg.sender, msg.value, block.timestamp, 0));   
    emit DepositAt(msg.sender, tariff, tokenVal);
}



function isContract(address addr) internal view returns (bool) {
    uint size;
    assembly { size := extcodesize(addr) }
    return size > 0;
}


  function buyWithToken(uint amount,uint investToken) external {
        require(investToken==1 || investToken==2 || investToken==3 || investToken==4 , "invalid Token");

        address duductToken = usdt;
        uint currencyPrice = 1; 
        uint currencyPriceDecimal = 0;

        if(investToken==1){
            duductToken = wbtc;
            priceOfWbtc = priceConsumerV3.getThePriceBtc();
            currencyPrice = priceOfWbtc;
            currencyPriceDecimal = 8;
        }
        else if(investToken==2){
            duductToken = weth;
            priceOfWeth = priceConsumerV3.getThePriceEth();
            currencyPrice = priceOfWeth;
            currencyPriceDecimal = 8;
        }
        else if(investToken==3){
            duductToken = usdt;
        }
        else {
            duductToken = usdc;
        }
        BEP20 receiveToken = BEP20(duductToken);  
           
        
        
        uint tokenVal = (amount* currencyPrice* (10**tokenPriceDecimal)) / (tokenPrice * (10**currencyPriceDecimal)) ; 
        
        require(receiveToken.balanceOf(msg.sender) >= amount, "Insufficient user balance");
      
       receiveToken.transferFrom(msg.sender, contractAddr, amount);
       
        investors[msg.sender].invested += tokenVal;
        investors[msg.sender].deposits.push(Deposit(investToken,amount,tokenVal,block.timestamp));
        allTokenPurchases.push(TokenPurchase(msg.sender, amount, block.timestamp, investToken));   
         emit DepositAt(msg.sender, investToken, tokenVal);
  
  } 



    // Set buy price  
  function setBuyPrice(uint _price, uint _decimal) public {
    require(msg.sender == owner || msg.sender == owner1, "Only owner or owner1");
    tokenPrice = _price;
    tokenPriceDecimal = _decimal;
}
 


  function updateOwner1(address _newOwner1) public {
      require(msg.sender == owner, "Only owner can update owner1");
      owner1 = _newOwner1;
}       

function updatecontractadd(address payable _newaddr) public {
   require(msg.sender == owner, "only owner can update contractadd");
   contractAddr = _newaddr; 
}

          // Owner BNB Withdraw    
    // Only owner can withdraw BNB 
      function withdrawBNB(address payable to, uint amount) public nonReentrant returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        to.transfer(amount);
        return true;
    }

      function usd_price() public view returns (uint) {
      return priceOfBNB;
  }

   function tokenInBNB(uint amount) public view returns (uint) {
        uint tokenVal = (amount * priceOfBNB* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;
        return (tokenVal);    
    }
  

    function tokenInBUSD(uint amount) public view returns (uint) {
        uint tokenVal = (amount * 10**tokenPriceDecimal ) /(tokenPrice*1000000000000000000) ;
        return (tokenVal);
    }

     function tokenInWeth(uint amount) public view returns (uint) {
        uint tokenVal = (amount * priceOfWeth* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;
        return (tokenVal);
    }

     function tokenInWbtc(uint amount) public view returns (uint) {
        uint tokenVal = (amount * priceOfWbtc* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;
        return (tokenVal);
    }

    // Owner Token Withdraw    
    // Only owner can withdraw token 

    function withdrawToken(address tokenAddress, address to, uint amount) public nonReentrant returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        BEP20 _token = BEP20(tokenAddress);
        _token.transfer(to, amount);
        return true;
    }

     function setMinbusd(uint _busdAmt) public {
      require(msg.sender == owner, "Only owner");
      MIN_DEPOSIT_BUSD = _busdAmt;
    }

    // Ownership Transfer
    // Only owner can call this function  
    function transferOwnership(address to) public returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot transfer ownership to zero address");
        owner = to;
        emit OwnershipTransferred(to);
        return true;
    }



        // View details
    function userDeposits(address indexAddress) public view returns (uint[] memory tariffs,uint[] memory amounts,uint[] memory getTokens, uint[] memory times) {
        uint len = investors[indexAddress].deposits.length;
        tariffs = new uint[](len);
        amounts = new uint[](len);
        getTokens = new uint[](len);
        times = new uint[](len);
        
        for(uint i = 0; i <len; i++){
            tariffs[i] = investors[indexAddress].deposits[i].tariff;
            amounts[i] = investors[indexAddress].deposits[i].amount;
            getTokens[i] = investors[indexAddress].deposits[i].tokenAmount;
            times[i] = investors[indexAddress].deposits[i].at;
            
        }
        return (tariffs, amounts, getTokens, times);
    }

    function allPrice() public view returns (uint ,uint ,uint,uint,uint,uint,uint) {

        return (priceOfBNB, tokenPrice, tokenPriceDecimal,priceOfWbtc,8, priceOfWeth, 8);
    }   

    function getAllTokenPurchases() public view returns (TokenPurchase[] memory) {
           return allTokenPurchases;
}


}