// SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";


interface AggregatorV3Interface {

  function decimals() external view returns (uint);
  function description() external view returns (string memory); 
  function version() external view returns (uint);

  // getRoundData and latestRoundData should both raise "No data present"
  // if they do not have data to report, instead of returning unset values
  // which could be misinterpreted as actual reported values.
  function getRoundData(uint80 _roundId)
    external
    view
    returns (
      uint roundId,
      uint answer,
      uint startedAt,  
      uint updatedAt,
      uint answeredInRound
    );
  function latestRoundData()    
    external 
    view 
    returns ( 
      uint roundId, 
      uint answer, 
      uint startedAt, 
      uint updatedAt,  
      uint answeredInRound   
    );

}
contract PriceConsumerV3 {     
 
    AggregatorV3Interface internal priceFeed;
   

 constructor() {
        priceFeed = AggregatorV3Interface(0x0A77230d17318075983913bC2145DB16C7366156);  // AVAX  / usd address Mainnet 

    }

    function getThePrice() public view returns (uint) {
        (
            uint roundID, 
            uint price,  
            uint startedAt,
            uint timeStamp,
            uint answeredInRound
        ) = priceFeed.latestRoundData();
        return price;
    }
   
}

interface BEP20 {
    function totalSupply() external view returns (uint theTotalSupply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external ;
    function transferFrom(address _from, address _to, uint _value) external ;
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}   

interface ERC20 {
    function totalSupply() external view returns (uint theTotalSupply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}   

contract GasWizard is ReentrancyGuard {  
  
   PriceConsumerV3 priceConsumerV3 = new PriceConsumerV3(); 
   uint public priceOfAVAX = priceConsumerV3.getThePrice();
                  
                  
  struct Tariff {
    uint time;  
    uint percent;
  }
  
  struct Deposit { 
    uint tariff;
    uint amount;
    uint tokenAmount;
    uint at;
  }
  
  struct Investor {
    bool registered;
    Deposit[] deposits;
    uint invested;
    
  } 

   struct TokenPurchase {
        address buyer; 
        uint amount;
        uint timestamp;
        uint amountType ;  // 0 = AVAX , 1 =token 

    } 
    TokenPurchase[] public allTokenPurchases;

  // TestNet 
   address public usdt = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7;  //USDT Mainnet
   address public usdc = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;  // USDC Mainnet 

  uint public tokenPrice = 1 ;       
  uint public tokenPriceDecimal = 2;   



  event OwnershipTransferred(address);
  
  address public owner = msg.sender;
  address public owner1 = 0xe65E456C12881c00AA30CeAA2360100E5AcF9BF1 ;
  
  
  uint public totalInvested;
   address  payable  public   contractAddr = payable(0x6229C80d2576d3A9fe74A85891a0AB6de87628d9);
  
  mapping (address => Investor) public investors;
  mapping(address => TokenPurchase[]) public tokenPurchases;
  event DepositAt(address user, uint tariff, uint amount);
  event Withdraw(address user, uint amount);
  
  constructor() {
    tokenPrice = 1;
    tokenPriceDecimal = 2;


  }

function buyTokenWithAVAX(address payable _to) external payable  nonReentrant { 
    uint tariff = 0;
    require(msg.value >= 0);
    priceOfAVAX = priceConsumerV3.getThePrice();
    uint tokenVal = (msg.value * priceOfAVAX * 10**tokenPriceDecimal) / (tokenPrice * 100000000);
    
        
    if (isContract(_to)) {
        (bool success, ) = _to.call{value: msg.value}("");
        require(success, "Transfer to contract failed");
    } else {
        _to.transfer(msg.value);
    }

    investors[msg.sender].invested += tokenVal;
    investors[msg.sender].deposits.push(Deposit(tariff, msg.value, tokenVal, block.timestamp));
    allTokenPurchases.push(TokenPurchase(msg.sender, msg.value, block.timestamp, 0));   
    emit DepositAt(msg.sender, tariff, tokenVal);
}



function isContract(address addr) internal view returns (bool) {
    uint size;
    assembly { size := extcodesize(addr) }
    return size > 0;
}


 function buyWithToken(uint amount,uint investToken) external nonReentrant  {
        require(investToken==1 || investToken==2 , "invalid Token");

        address duductToken = usdt;
        address duductTokens = usdc;

         if(investToken==1){
         BEP20 receiveToken = BEP20(duductToken);  
         require(receiveToken.balanceOf(msg.sender) >= amount, "Insufficient user balance");
        receiveToken.transferFrom(msg.sender, contractAddr, amount);

        }
        else  {
            duductTokens = usdc;
        ERC20 receiveTokens = ERC20(duductTokens);
        require(receiveTokens.balanceOf(msg.sender) >= amount, "Insufficient user balance");
        receiveTokens.transferFrom(msg.sender, contractAddr, amount);


        }
        uint tokenVal = (amount* 10**tokenPriceDecimal) / tokenPrice  ; 

        investors[msg.sender].invested += tokenVal;
        investors[msg.sender].deposits.push(Deposit(investToken,amount,tokenVal,block.timestamp));
        allTokenPurchases.push(TokenPurchase(msg.sender, amount, block.timestamp, investToken));   
         emit DepositAt(msg.sender, investToken, tokenVal);
  
  } 

    // Set buy price  
  function setBuyPrice(uint _price, uint _decimal) public  nonReentrant {
    require(msg.sender == owner || msg.sender == owner1, "Only owner or owner1");
    tokenPrice = _price;
    tokenPriceDecimal = _decimal;
}


  function updateOwner1(address _newOwner1) public  nonReentrant {
      require(msg.sender == owner, "Only owner can update owner1");
      owner1 = _newOwner1;
}


function updatecontractadd(address payable _newaddr) public nonReentrant  {
   require(msg.sender == owner, "only owner can update contractadd");
   contractAddr = _newaddr; 
}

    // Owner ArbitrumETH Withdraw    
    // Only owner can withdraw ArbitrumETH 
      function withdrawArbitrum(address payable to, uint amount) public nonReentrant  returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        to.transfer(amount);
        return true;
    }

      function usd_price() public view returns (uint) {
      return priceOfAVAX;
  }

   function tokenInAVAX(uint amount) public view returns (uint) {
        uint tokenVal = (amount * priceOfAVAX* 10**tokenPriceDecimal) /(tokenPrice*100000000*1000000000000000000) ;
        return (tokenVal);    
    }
  
    function tokenInUSDT(uint amount) public view returns (uint) {
        uint tokenVal = (amount * 10**tokenPriceDecimal ) /(tokenPrice*1000000000000000000) ;
        return (tokenVal);
    }

    // Owner Token Withdraw    
    // Only owner can withdraw token 

    function withdrawToken(address tokenAddress, address to, uint amount) public nonReentrant  returns(bool) {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot send to zero address");
        BEP20 _token = BEP20(tokenAddress);
        _token.transfer(to, amount);
        return true;
    }

    // Ownership Transfer
    // Only owner can call this function
    function transferOwnership(address to) public  nonReentrant returns(bool)  {
        require(msg.sender == owner, "Only owner");
        require(to != address(0), "Cannot transfer ownership to zero address");
        owner = to;
        emit OwnershipTransferred(to);
        return true;
    }

        // View details
    function userDeposits(address indexAddress) public view returns (uint[] memory tariffs,uint[] memory amounts,uint[] memory getTokens, uint[] memory times) {
        uint len = investors[indexAddress].deposits.length;
        tariffs = new uint[](len);
        amounts = new uint[](len);
        getTokens = new uint[](len);
        times = new uint[](len);
        
        for(uint i = 0; i <len; i++){
            tariffs[i] = investors[indexAddress].deposits[i].tariff;
            amounts[i] = investors[indexAddress].deposits[i].amount;
            getTokens[i] = investors[indexAddress].deposits[i].tokenAmount;
            times[i] = investors[indexAddress].deposits[i].at;
            
        }
        return (tariffs, amounts, getTokens, times);
    }

    function allPrice() public view returns (uint ,uint ,uint,uint,uint,uint,uint) {
       
        return (priceOfAVAX, tokenPrice, tokenPriceDecimal,0,8 ,0,0);
    }   

    function getAllTokenPurchases() public view returns (TokenPurchase[] memory) {
           return allTokenPurchases;
}


}